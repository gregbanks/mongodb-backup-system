#!/usr/bin/env python

__author__ = 'abdul'

import sys
import traceback
import os
import signal

from functools import partial


from dargparse import dargparse
from bson.objectid import ObjectId
from mbs.mbs import get_mbs
from mbs.engine import STATUS_STOPPED, STATUS_STOPPING, STATUS_RUNNING
from mbs.utils import (
    wait_for, document_pretty_string, resolve_path, SignalWatcher
)
from mbs import mbs_config
from mbs.mbs_logging import setup_logging

###############################################################################
# MAIN
###############################################################################
def main(args):
    parser = dargparse.build_parser(PARSER_DEF)

    if len(args) < 1:
        parser.print_help()
        return

    # Parse the arguments and call the function of the selected cmd
    parsed_args = parser.parse_args(args)

    mbs_config.MBS_CONF_DIR = resolve_path(parsed_args.config_root)

    setup_logging(not getattr(parsed_args, "fork", False))

    # get the function to call from the parser framework
    command_function = parsed_args.func

    return command_function(parsed_args)

###############################################################################
# Engine Commands
###############################################################################
def start_engine(parsed_args):
    engine_id = parsed_args.engineId
    engine = _get_engine(engine_id)

    handlers = {signal.SIGINT:  partial(engine.stop, force=False),
                signal.SIGTERM: partial(engine.stop, force=True)}
    with SignalWatcher(handlers) as watcher:
        status = engine.get_status()
        if status["status"] == STATUS_RUNNING:
            print "Engine already started"
            return
        elif status["status"] == STATUS_STOPPING:
            print ("Engine is stopping now. Please wait until it is "
                   "completely stopped then try starting again")
            return

        _do_start_engine(engine, fork=parsed_args.fork)

        wait_for(partial(_engine_started, engine), timeout=5)

        if _engine_started(engine):
            print "Engine started successfully!"
        else:
            print "Engine did not start. Please check logs"
            return

        wait_for(lambda: watcher.signaled or not engine.is_alive(),
                 log_func=lambda: True)


###############################################################################
def _do_start_engine(engine, fork=False):
    if fork:
        child_pid = os.fork()
        if child_pid:
            # parent process. return
            print "Forked engine process %s" % child_pid
            return
        else:
            # need to disown yourself, Son
            os.setsid()
            os.umask(0)

    # forked child process
    engine.start()

###############################################################################
def _engine_started(engine):
    return engine.get_status()["status"] == STATUS_RUNNING

###############################################################################
def stop_engine(parsed_args):
    engine_id = parsed_args.engineId
    engine = _get_engine(engine_id)
    status = engine.get_status()
    if status["status"] == STATUS_STOPPING:
        print "A stop request has already been made"
        return
    elif status["status"] == STATUS_STOPPED:
        print "Engine is not running"
        return

    _do_stop_engine(engine, parsed_args.force)

###############################################################################
def _engine_stopped(engine):
    return engine.get_status()["status"] == STATUS_STOPPED

###############################################################################
def _do_stop_engine(engine, force=False):
    print "stopping engine"
    engine.stop(force=force)
    print "Waiting for engine to stop"
    wait_for(partial(_engine_stopped, engine), timeout=100)
    print "Done waiting for engine to stop"
    if _engine_stopped(engine):
        exit(0)
    else:
        print "Unable to stop engine within 100 seconds"
        exit(1)

###############################################################################
def restart_engine(parsed_args):
    engine_id = parsed_args.engineId
    engine = _get_engine(engine_id)

    # stop the engine and wait for it is completely stopped
    engine.stop()

    wait_for(partial(_engine_stopped, engine), timeout=100)

    if _engine_stopped(engine):
        start_engine(parsed_args)
    else:
        print "Engine did not stop yet. Please try later"
        exit(1)

###############################################################################
def status_engine(parsed_args):
    engine_id = parsed_args.engineId
    engine = _get_engine(engine_id)
    print document_pretty_string(engine.get_status())

###############################################################################
# Backup System Commands
###############################################################################
def start_backup_system(parsed_args):
    backup_system = get_mbs().backup_system
    if not backup_system:
        print "No backup system configured"
        exit(1)

    handlers = {signal.SIGINT:  partial(backup_system.stop, force=False),
                signal.SIGTERM: partial(backup_system.stop, force=True)}
    with SignalWatcher(handlers) as watcher:
        status = backup_system.get_status()
        if status["status"] == STATUS_RUNNING:
            print "Backup System already started"
            return
        elif status["status"] == STATUS_STOPPING:
            print ("Backup System is stopping now. Please wait until it is "
                   "completely stopped then try starting again")
            return

        _do_start_backup_system(fork=parsed_args.fork)

        def backup_system_started():
            return backup_system.get_status()["status"] == STATUS_RUNNING
        wait_for(backup_system_started, timeout=5)

        if backup_system_started():
            print "Backup System started successfully!"
        else:
            print "Backup System did not start. Please check logs"

        wait_for(lambda: watcher.signaled or not backup_system.is_alive(),
                 log_func=lambda: True)

###############################################################################
def _do_start_backup_system(fork=False):
    if fork:
        child_pid = os.fork()
        if child_pid:
            # parent process. return
            print "Forked backup system process %s" % child_pid
            return
        else:
            # need to disown yourself, Son
            os.setsid()
            os.umask(0)

    # forked child process
    backup_system = get_mbs().backup_system
    backup_system.start()

###############################################################################
def stop_backup_system(parsed_args):
    backup_system = get_mbs().backup_system
    if not backup_system:
        print "No backup system configured"
        exit(1)

    status = backup_system.get_status()
    if status["status"] == STATUS_STOPPING:
        print "A stop request has already been made"
        return
    elif status["status"] == STATUS_STOPPED:
        print "Backup System is not running"
        return

    backup_system.stop(force=parsed_args.force)

###############################################################################
def restart_backup_system(parsed_args):
    backup_system = get_mbs().backup_system

    if not backup_system:
        print "No backup system configured"
        exit(1)
    # stop the backup_system and wait for it is completely stopped
    backup_system.stop()
    def backup_system_stopped():
        return backup_system.get_status()["status"] == STATUS_STOPPED

    wait_for(backup_system_stopped, timeout=100)

    if backup_system_stopped():
        start_backup_system(parsed_args)
    else:
        print "Backup System did not stop yet. Please try later"
        exit(1)

###############################################################################
def status_backup_system(parsed_args):
    backup_system = get_mbs().backup_system
    if not backup_system:
        print "No backup system configured"
        exit(1)

    print document_pretty_string(backup_system.get_status())

###############################################################################
def run_plan_generators(parsed_args):
    backup_system = get_mbs().backup_system
    if not backup_system:
        print "No backup system configured"
        exit(1)

    backup_system._run_plan_generators()


###############################################################################
# Other Commands
###############################################################################
def generate_audit_reports(parsed_args):
    global_auditor = get_mbs().backup_system.global_auditor
    global_auditor.generate_yesterday_audit_reports()

###############################################################################
def download_backup(parsed_args):

    try:
        backup_id = parsed_args.backupId
        bc = get_mbs().backup_collection
        backup = bc.find_one({"_id": ObjectId(backup_id)})

        if backup:
            if backup.target_reference:
                if not backup.target_reference.expired:
                    backup.target.get_file(backup.target_reference, os.getcwd())
                else:
                    print ("Failed to download. Backup '%s' is expired." %
                           backup_id)
                    exit(1)


            else:
                print ("Failed to download. Backup '%s' never uploaded."
                       % backup_id)
                exit(1)
        else:
            print "No such backup '%s'" % backup_id
            exit(1)
    except Exception, e:
        print "%s" % e
        exit(1)

###############################################################################
def reschedule_backup(parsed_args):

    try:
        from_scratch = parsed_args.fromScratch
        backup_id = parsed_args.backupId
        bc = get_mbs().backup_collection
        backup = bc.find_one({"_id": ObjectId(backup_id)})

        if backup:
           get_mbs().backup_system.reschedule_backup(backup, from_scratch=
                                                             from_scratch)
        else:
            print "No such backup '%s'" % backup_id
            exit(1)
    except Exception, e:
        print "%s" % e
        exit(1)

###############################################################################
def reschedule_all_backups(parsed_args):

    try:
        from_scratch = parsed_args.fromScratch
        get_mbs().backup_system.reschedule_all_failed_backups(from_scratch=
                                                              from_scratch)
    except Exception, e:
        print "%s" % e
        exit(1)

###############################################################################
def cancel_backup(parsed_args):

    try:
        backup_id = parsed_args.backupId
        bc = get_mbs().backup_collection
        backup = bc.find_one({"_id": ObjectId(backup_id)})

        if backup:
           get_mbs().backup_system.cancel_backup(backup)
        else:
            print "No such backup '%s'" % backup_id
            exit(1)
    except Exception, e:
        print "%s" % e
        exit(1)

###############################################################################
def cancel_backups(parsed_args):

    try:
        tags = None
        if parsed_args.backupTags is not None:
            tags = dict(parsed_args.backupTags)
        get_mbs().backup_system.cancel_backups(tags)
    except Exception, e:
        print "%s" % e
        exit(1)

###############################################################################
def schedule_plan_backup(parsed_args):
    try:
        plan_id = parsed_args.planId
        pc = get_mbs().plan_collection
        plan = pc.find_one({"_id": ObjectId(plan_id)})

        if plan:
            get_mbs().backup_system.schedule_new_backup(plan, one_time=True)
        else:
            print "No such plan '%s'" % plan_id
            exit(1)
    except Exception, e:
        print "%s" % e
        exit(1)

###############################################################################
# Helpers
###############################################################################
def _get_engine(engine_id=None):

    if not engine_id:
        return get_mbs().get_default_engine()
    else:
        return get_mbs().get_engine(engine_id)

###############################################################################
# command parser
###############################################################################
PARSER_DEF = {
    "prog": "mbs",
    "usage": "Usage: mbs [<options>] <command> [<command-args>]",
    "description" : "contains commands for the mongodb-backup-system",
    "args": [
            {
            "name": "config_root",
            "type": "optional",
            "cmd_arg": "--config-root",
            "displayName": "CONFIGROOT",
            "help": "path to mbs config root; defaults to %(default)s",
            "default": mbs_config.MBS_CONF_DIR
        }
    ],
    "children":[
        #### start-engine ####
            {
            "prog": "start-engine",
            "shortDescription" : "starts a backup engine",
            "description" : "starts a backup engine",
            "function": start_engine,
            "args": [
                    {
                    "name": "engineId",
                    "type" : "positional",
                    "nargs": "?",
                    "displayName": "ENGINE_ID",
                    "help": "An engine id"
                },
                    {
                    "name": "fork",
                    "type" : "optional",
                    "cmd_arg":  "--fork",
                    "nargs": 0,
                    "help": "fork the engine process",
                    "action": "store_true",
                    "default": False
                }
            ]
        },

        #### stop-engine ####
            {
            "prog": "stop-engine",
            "shortDescription" : "stops a backup engine",
            "description" : "stops a backup engine",
            "function": stop_engine,
            "args": [
                    {
                    "name": "engineId",
                    "type" : "positional",
                    "nargs": "?",
                    "displayName": "ENGINE_ID",
                    "help": "An engine id"
                } ,
                    {
                    "name": "force",
                    "type" : "optional",
                    "cmd_arg":  ["--force", "-f"],
                    "nargs": 0,
                    "help": "force stop engine",
                    "action": "store_true",
                    "default": False
                }
            ]
        },
        #### status-engine ####
            {
            "prog": "status-engine",
            "shortDescription" : "gets the status of a backup engine",
            "description" : "gets the status of a backup engine",
            "function": status_engine,
            "args": [
                    {
                    "name": "engineId",
                    "type" : "positional",
                    "nargs": "?",
                    "displayName": "ENGINE_ID",
                    "help": "An engine id"
                }
            ]
        },

        #### restart-engine ####
            {
            "prog": "restart-engine",
            "shortDescription" : "restarts the backup engine",
            "description" : "restarts the backup engine",
            "function": restart_engine,
            "args": [
                    {
                    "name": "engineId",
                    "type" : "positional",
                    "nargs": "?",
                    "displayName": "ENGINE_ID",
                    "help": "An engine id"
                },
                    {
                    "name": "fork",
                    "type" : "optional",
                    "cmd_arg":  "--fork",
                    "nargs": 0,
                    "help": "fork the engine process",
                    "action": "store_true",
                    "default": False
                }
            ]
        },
            {
            "prog": "start-backup-system",
            "shortDescription" : "starts the backup system",
            "description" : "starts the backup system",
            "function": start_backup_system,
            "args": [
                    {
                    "name": "fork",
                    "type" : "optional",
                    "cmd_arg":  "--fork",
                    "nargs": 0,
                    "help": "fork the engine process",
                    "action": "store_true",
                    "default": False
                }
            ]
        },

        #### stop-backup-system ####
            {
            "prog": "stop-backup-system",
            "shortDescription" : "stops the backup system",
            "description" : "stops the backup system",
            "function": stop_backup_system,
            "args": [
                    {
                    "name": "force",
                    "type" : "optional",
                    "cmd_arg":  ["--force", "-f"],
                    "nargs": 0,
                    "help": "force stop backup_system",
                    "action": "store_true",
                    "default": False
                }
            ]
        },
        #### status-backup-system ####
            {
            "prog": "status-backup-system",
            "shortDescription" : "gets the status of the backup system",
            "description" : "gets the status of the backup system",
            "function": status_backup_system
        },

        #### restart-backup-system ####
            {
            "prog": "restart-backup-system",
            "shortDescription" : "restart backup system",
            "description" : "restart backup system",
            "function": restart_backup_system,
            "args": [
                    {
                    "name": "fork",
                    "type" : "optional",
                    "cmd_arg":  "--fork",
                    "nargs": 0,
                    "help": "fork the engine process",
                    "action": "store_true",
                    "default": False
                }
            ]
        },
        #### run-plan-generators ####
            {
            "prog": "run-plan-generators",
            "shortDescription" : "Runs plans generators",
            "description" : "Runs plans generators",
            "function": run_plan_generators
        },
            {
            "prog": "generate-audit-reports",
            "shortDescription" : "generates audit reports as of yesterday",
            "description" : "generates audit reports as of yesterday",
            "function": generate_audit_reports
        },

            {
            "prog": "download-backup",
            "shortDescription" : "Downloads backup file from target to "
                                 "current working directory",
            "description" : "Downloads backup file from target to "
                            "current working directory",
            "args": [
                {
                "name": "backupId",
                "type" : "positional",
                "nargs": 1,
                "displayName": "BACKUP_ID",
                "help": "Backup id"
            }],
            "function": download_backup
        },

            {
            "prog": "reschedule-backup",
            "shortDescription" : "Reschedules specified backup",
            "description" : "Reschedules specified backup. "
                            "Only applicable to failed backups",
            "args": [
                    {
                    "name": "backupId",
                    "type" : "positional",
                    "nargs": 1,
                    "displayName": "BACKUP_ID",
                    "help": "Backup id"
                },
                    {
                    "name": "fromScratch",
                    "type" : "optional",
                    "cmd_arg":  ["--from-scratch"],
                    "nargs": 0,
                    "help": "clears backup log",
                    "action": "store_true",
                    "default": False
                }

            ],
            "function": reschedule_backup
        },

            {
            "prog": "reschedule-all-backups",
            "shortDescription" : "Reschedules all failed backups",
            "description" : "Reschedules all failed backups",
            "args": [
                    {
                    "name": "fromScratch",
                    "type" : "optional",
                    "cmd_arg":  ["--from-scratch"],
                    "nargs": 0,
                    "help": "clears backup log",
                    "action": "store_true",
                    "default": False
                }

            ],
            "function": reschedule_all_backups
        },
            
            {
            "prog": "cancel-backup",
            "shortDescription" : "Cancels specified backup",
            "description" : "Cancels specified backup. "
                            "Only applicable to failed and scheduled backups",
            "args": [
                    {
                    "name": "backupId",
                    "type" : "positional",
                    "nargs": 1,
                    "displayName": "BACKUP_ID",
                    "help": "Backup id"
                }
            ],
            "function": cancel_backup
        },

            {
            "prog": "cancel-backups",
            "shortDescription" : "Cancels multiple backups",
            "description" : "Cancels multiple backups, optionally filtering "
                            "by tag",
            "args": [
                    {
                    "name": "backupTags",
                    "type" : "optional",
                    "cmd_arg":  ["--tag"],
                    "nargs": 2,
                    "help": "filter on tag (can be specified multiple times)",
                    "displayName": ("TAG", "VALUE"),
                    "action": "append"
                }
            ],
            "function": cancel_backups,
        },

            {
            "prog": "schedule-plan-backup",
            "shortDescription" : "Schedules a one-time backup for the "
                                 "specified plan",
            "description" : "Schedules a one-time backup for the "
                            "specified plan",
            "args": [
                    {
                    "name": "planId",
                    "type" : "positional",
                    "nargs": 1,
                    "displayName": "PLAN_ID",
                    "help": "Plan id"
                }],
            "function": schedule_plan_backup
        }
    ]
}

###############################################################################
########################                   ####################################
########################     BOOTSTRAP     ####################################
########################                   ####################################
###############################################################################


if __name__ == '__main__':
    try:

        main(sys.argv[1:])
    except (SystemExit, KeyboardInterrupt) , e:
        if hasattr(e, 'code') and e.code == 0:
            pass
        else:
            raise
    except:
        traceback.print_exc()
